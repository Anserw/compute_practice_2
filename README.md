# 数值分析 计算实习 第二题 
SY1517303 徐子尧

## 1. 题目描述
试求矩阵$A=[a_{ij}]_{10\times10}$的全部特征值，并对其中的每一个实特征值求相应的特征向量。已知 
$$a_{i,j}=\left\{\begin{matrix}sin(0.5i+0.2j)
 & i\neq j\\1.52cos(i+1.2j) 
 & i=j
\end{matrix}\right. \qquad   (i,j=1,2,\cdots ,10)$$

### 说明： 
1. 求矩阵特征值时，要求迭代的精度水平为$\varepsilon=10^{-12} $
2. 打印以下内容： 
    - 全部源程序。 
    - 矩阵$A$经过拟上三角化后所得的矩阵$A^{(n-1)}$
    - 对矩阵$A^{(n-1)}$实行QR分解方法结束后所得的矩阵。 
    - 矩阵A的全部特征值$\lambda_i=(R_i, I_i) \ (i=1,2,\cdots ,10)$，其中$R_i=Re(\lambda_i), I_i=Im(\lambda_i)$，若$\lambda_i$是实数，就令$I_i=0$。 
    - 矩阵$A$的相应于实特征值的特征向量。 
3. 采用e型输出实型数，并且至少显示12位有效数字。

## 2. 算法设计

```flow
st=>start: Start
e=>end: end
op0=>operation: 初始化矩阵，计算初值
op1=>operation: 矩阵的拟上三角化
op2=>operation: 用带双步位移的QR方法求解所有特征值
cond1=>condition: 判断是否是实特征值
op3=>operation: 用Gauss消去法求解对应的特征向量
opqr=>operation: 计算拟上三角化后矩阵的QR分解，并打印RQ
io=>inputoutput: 输出结果
st->op0->opqr->op1->op2->cond1
cond1(yes)->op3
cond1(no)->io
op3->io
io->e
```


1. 拟上三角化
按照*数值分析, 闫庆津, 第四版*中61页3.3.2的方法，求得矩阵A经过拟上三角化后的矩阵$A^{(n-1)}$。
此步可以为后续计算减少计算量。

2. 带双步位移的QR方法
按照*数值分析, 闫庆津, 第四版*中62页3.3.3的方法。
QR方法产生的矩阵序列本质上收敛于分块上三角阵。对角块均是一阶或二阶子块，对每个子块求特征值就得到整个矩阵的所有特征值。为加速收敛，采用带双步位移的QR分解法。记最大迭代次数为Max，取为1000，迭代精度为e=1e-12。
每次迭代前检查，若下一个子块满足条件（一阶或二阶），输所有特征值，计算完成。若达到最大迭代次数仍未输出所有特征值，则返回错误信息，计算失败。

3. 列主元素Gauss消去法
按照*数值分析, 闫庆津, 第四版*中16页2.1.2的方法。
对每个实特征值$λ_i$，解线性方程$(A-λ_i I)X=0$，因为系数矩阵非满秩的，统一置特征向量的最后一个值为1。

## 3. 程序代码
```cpp
// compute_practice_2.cpp 
//带双步位移的QR方法

#include<stdio.h>
#include<stdlib.h>
#include<math.h>

const double e = 1e-12;      //迭代的精度水平
const int Max = 1000;        //迭代的最大次数

//定义复数结构体
typedef struct{
    double Re;
    double Im;
}ComplexNumber;

//初始化矩阵
void initMat(double **& a)
{
    int i, j;
    a = (double **)malloc(10 * sizeof(double *));
    for (i = 0; i<10; i++)
        a[i] = (double *)malloc(11 * sizeof(double));
    for (i = 0; i<10; i++) {
        for (j = 0; j<10; j++) {
            if (i != j)
                a[i][j] = sin(0.5*(i + 1) + 0.2*(j + 1));
            else
                a[i][j] = 1.52*cos(i + 1 + 1.2*(j + 1));
        }
    }
}

//将矩阵中小于e的值全部赋值为0
void zeroMat(double **a)
{
    int i, j;
    for (i = 0; i<10; i++) {
        for (j = 0; j<10; j++) {
            if (a[i][j]<e&&a[i][j]>-e)
                a[i][j] = 0;
        }
    }
}

//输出矩阵
int printMat(double **a)
{
    int i, j;
    for (i = 0; i<10; i++)
    {
        for (j = 0; j<10; j++)
            printf("%.12e ", a[i][j]);
        printf("\n");
    }
    printf("\n\n\n");
    return 0;
}

//将矩阵拟上三角化
void hessenbergMat(double **a)       
{
    int r, i, j;
    double c, d, h, t, u[10], p[10], q[10], w[10];
    for (r = 0; r<8; r++) {
        zeroMat(a);
        c = 0; d = 0; h = 0;
        for (i = r + 2; i<10; i++)
            d += a[i][r] * a[i][r];
        if (d == 0)
            continue;
        else {
            d += a[r + 1][r] * a[r + 1][r];
            d = pow(d, 0.5);
            if (a[r + 1][r] != 0)
                c = -fabs(a[r + 1][r]) / a[r + 1][r] * d;
            else 
                c = d;
            h = c*c - c*a[r + 1][r];
            for (i = 0; i<r + 1; i++)
                u[i] = 0;
            u[r + 1] = a[r + 1][r] - c;
            for (i = r + 2; i<10; i++) 
                u[i] = a[i][r];
            for (i = 0; i<10; i++) {
                p[i] = 0; q[i] = 0;
                for (j = 0; j<10; j++) {
                    p[i] += a[j][i] * u[j] / h;
                    q[i] += a[i][j] * u[j] / h;
                }
            }
            t = 0;
            for (i = 0; i<10; i++)
                t += p[i] * u[i] / h;
            for (i = 0; i<10; i++)
                w[i] = q[i] - t*u[i];
            for (i = 0; i<10; i++) {
                for (j = 0; j<10; j++)
                    a[i][j] -= (w[i] * u[j] + u[i] * p[j]);
            }
        }
    }
    printf("A(n-1)\n");
    zeroMat(a);
    printMat(a);
}

//矩阵乘法
void muiltiplyMat(double **a, double **b, double **c, int m)
{    
    for (int i = 0; i<m; i++) {
        for (int j = 0; j<m; j++) {
            c[i][j] = 0;
            for (int k = 0; k<m; k++)
                c[i][j] += a[i][k] * b[k][j];
        }
    }
}

//QR分解中的迭代运算
void iterate(double **M, double **a, int m)
{
    int r, i, j;
    double c, d, h, t, u[10], v[10], p[10], q[10], w[10];
    for (r = 0; r<m - 1; r++) {
        zeroMat(M);
        c = 0; d = 0; h = 0;
        for (i = r + 1; i<m; i++)
            d += M[i][r] * M[i][r];
        if (fabs(d) == 0)
            continue;
        else {
            d += M[r][r] * M[r][r];
            d = pow(d, 0.5);
            if (M[r][r] != 0)
                c = -fabs(M[r][r]) / M[r][r] * d;
            else 
                c = d;
            h = c*c - c*M[r][r];
            for (i = 0; i<r; i++)u[i] = 0;
            u[r] = M[r][r] - c;
            for (i = r + 1; i<m; i++) 
                u[i] = M[i][r];
            for (i = 0; i<m; i++) {
                v[i] = 0;
                for (j = 0; j<m; j++)
                    v[i] += M[j][i] * u[j] / h;
            }
            for (i = 0; i<m; i++) {
                p[i] = 0; q[i] = 0;
                for (j = 0; j<m; j++) {
                    M[i][j] -= u[i] * v[j];
                    p[i] += a[j][i] * u[j] / h;
                    q[i] += a[i][j] * u[j] / h;
                }
            }
            t = 0;
            for (i = 0; i<m; i++)
                t += p[i] * u[i] / h;
            for (i = 0; i<m; i++)
                w[i] = q[i] - t*u[i];
            for (i = 0; i<m; i++) {
                for (j = 0; j<m; j++) {
                    a[i][j] -= (w[i] * u[j] + u[i] * p[j]);
                }
            }
        }
    }
}

//Gauss消元法中的选主元
void maxline(double **ptr, int n, int k)
{
    double c;
    int i, M;
    M = k;
    for (i = k; i<n; i++) {
        if (fabs(ptr[i][k])>fabs(ptr[M][k]))
            M = i;
    }
    if (M>k) {
        for (i = k; i<n + 1; i++) {
            c = ptr[k][i];
            ptr[k][i] = ptr[M][i];
            ptr[M][i] = c;
        }
    }
}

//Gauss消元法
void gauss(double lambda)
{
    double **a;
    double *X;
    double m, sigma, t;
    int i, j, k, n = 10;
    X = (double *)malloc(10 * sizeof(double));
    initMat(a);

    for (i = 0; i<n; i++) {
        a[i][i] -= lambda;
        a[i][10] = 0;
    }

    for (k = 0; k<n - 1; k++) {
        maxline(a, n, k);
        for (i = k + 1; i<n; i++) {
            m = a[i][k] / a[k][k];
            for (j = k; j<n + 1; j++)
                a[i][j] = a[i][j] - m*a[k][j];
        }
    }

    X[n - 1] = 1;    
    t = 0;
    for (k = n - 2; k >= 0; k--) {
        sigma = 0;
        for (j = k + 1; j<n; j++)
            sigma += a[k][j] * X[j];
        X[k] = (a[k][n] - sigma) / a[k][k];
    }
    for (i = 0; i<n; i++)
        t += X[i] * X[i];
    t = sqrt(t);
    printf("eigenvector = ( ");
    for (i = 0; i<n; i++)
        printf("%.12e ", X[i]/t);
    printf(")\n");
    for (i = 0; i<10; i++)
        free(a[i]);
    free(a);
    free(X);
}

double inline sgn(double n)
{
    if (n > 0) {
        return 1;
    }
    else if (n < 0) {
        return -1;
    }
    else
        return 0;
}

//求Q、R和RQ
void QR_and_RQ(double **a)
{
    int i, j, r;
    double c, d, h, w[10], p[10], u[10];
    double **Q, **R, **RQ;
    Q = (double **)malloc(10 * sizeof(double *));
    for (i = 0; i < 10; i++)
        Q[i] = (double *)malloc(11 * sizeof(double));
    R = (double **)malloc(10 * sizeof(double *));
    for (i = 0; i < 10; i++)
        R[i] = (double *)malloc(11 * sizeof(double));
    RQ = (double **)malloc(10 * sizeof(double *));
    for (i = 0; i<10; i++)
        RQ[i] = (double *)malloc(11 * sizeof(double));
    for(i = 0; i < 10; i++) {
        for(j = 0; j < 10; j++){
            if(i == j)
                Q[i][i] = 1;
            else
                Q[i][j] = 0;
        }
    }
    for(i = 0; i < 10; i++) {
        for(j = 0; j < 10; j++)
            R[i][j] = a[i][j];
    }
    zeroMat(R);
    for(r = 0; r < 9; r++){
        d = 0;
        for(i = r + 1; i < 10; i++)
            d += R[i][r] * R[i][r];
        if(fabs(d) == 0)
            continue;
        else {
            d += R[r][r] * R[r][r];
            d = sqrt(d);
            if (R[r][r] == 0)
                c = d;
            else
                c = -sgn(R[r][r]) * d;
            h = c * c - c * R[r][r];
            for(i = 0; i < r; i++)
                u[i] = 0;
            u[r] = R[r][r] - c;
            for(i = r + 1; i < 10; i++)
                u[i] = R[i][r];
            for(i = 0; i < 10; i++) {
                w[i] = 0;
                for(j = 0; j < 10; j++)
                    w[i] += Q[i][j] * u[j];
            }
            for(i = 0; i < 10; i++) {
                for(j = 0; j < 10; j++)
                    Q[i][j] -= w[i] * u[j] / h;
            }
            for(i = 0; i < 10; i++){
                p[i] = 0;
                for(j = 0; j < 10; j ++ )
                    p[i] += R[j][i] * u[j] / h;
            }
            for(i = 0; i < 10; i++){
                for(j = 0; j < 10; j++)
                    R[i][j] -= u[i] * p[j];
            }
        }

    }
    zeroMat(R);
    zeroMat(Q);
    zeroMat(RQ);
    printf("Q:\n");
    printMat(Q);
    printf("R:\n");
    printMat(R);
    muiltiplyMat(R, Q, RQ, 10);
    printf("RQ:\n");
    printMat(RQ);
    for (i = 0; i < 10; i++)
        free(Q[i]);
    free(Q);
    for (i = 0; i < 10; i++)
        free(R[i]);
    free(R);
    for (i = 0; i<10; i++)
        free(RQ[i]);
    free(RQ);
} 

//带双布位移的QR分解方法
void QRmethod(double **a)
{
    int k, m, i, j, r;
    double s, t, det;
    double **M;
    ComplexNumber L[10];    
    M = (double**)malloc(10 * sizeof(double *));
    for (k = 0; k<10; k++)
        M[k] = (double*)malloc(10 * sizeof(double));

    m = 9; r = 0;
    for (k = 0; k<Max; k++)
    {
        if (m == 0) {
            L[r].Re = a[m][m];
            L[r].Im = 0; break;
        }
        else if (m < 0) {
            break;
        }
        if (fabs(a[m][m - 1])<e) {
            L[r].Re = a[m][m];
            L[r].Im = 0;
            m--; r++;
        }
        else {
            if (m == 1) {
                det = (a[m][m] + a[m - 1][m - 1])*(a[m][m] + a[m - 1][m - 1]) - 4 * (a[m][m] * a[m - 1][m - 1] - a[m - 1][m] * a[m][m - 1]);
                if (det > 0) {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2 + sqrt(det) / 2;
                    L[r].Im = 0;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2 - sqrt(det) / 2;
                    L[r + 1].Im = 0;
                }
                else {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r].Im = sqrt(-det) / 2;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r + 1].Im = -sqrt(-det) / 2;
                }
                m -= 2;
                r += 2;
                continue;
            }
            else if (fabs(a[m - 1][m - 2])<e) {
                det = (a[m][m] + a[m - 1][m - 1])*(a[m][m] + a[m - 1][m - 1]) - 4 * (a[m][m] * a[m - 1][m - 1] - a[m - 1][m] * a[m][m - 1]);
                if (det>0) {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2 + sqrt(det) / 2;
                    L[r].Im = 0;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2 - sqrt(det) / 2;
                    L[r + 1].Im = 0;
                }
                else {
                    L[r].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r].Im = sqrt(-det) / 2;
                    L[r + 1].Re = (a[m][m] + a[m - 1][m - 1]) / 2;
                    L[r + 1].Im = -sqrt(-det) / 2;
                }
                m -= 2;
                r += 2; 
                continue;
            }
            else {
                s = a[m - 1][m - 1] + a[m][m];
                t = a[m - 1][m - 1] * a[m][m] - a[m][m - 1] * a[m - 1][m];
                muiltiplyMat(a, a, M, m + 1);
                for (i = 0; i<10; i++)
                {
                    for (j = 0; j<10; j++)
                        M[i][j] -= s*a[i][j];
                    M[i][i] += t;
                }
                iterate(M, a, m + 1);
                zeroMat(a);
            }
        }
    }
    zeroMat(a);
    printf("after QR method\n");
    printMat(a);
    
    for (int r = 0; r<10; r++) {
        printf("\n");
        if (L[r].Im == 0) {
            printf("lambda[%d] = (%.12e + i*%.12e)\n", r + 1, L[r].Re, L[r].Im);
            gauss(L[r].Re);
        }
        else {
            printf("lambda[%d] = (%.12e + i*%.12e)\n", r + 1, L[r].Re, L[r].Im);
        }
    }
	for (int i = 0; i < 10; i++) {
		free(M[i]);
	}
	free(M);
}

int main()
{
    double **a;
    initMat(a);    
    hessenbergMat(a);    
    QR_and_RQ(a);
    QRmethod(a);
    return 0;
}
```
## 4. 运行结果

```
$ ./compute_practice_2
A(n-1)
-8.945216982281e-01 -9.933136491826e-02 -1.099831758877e+00 -7.665038709077e-01 1.707601141456e-01 -1.934882558889e+00 -8.390208705246e-02 9.132565113143e-01 -6.407977009188e-01 1.946733678685e-01 
-2.347878362416e+00 2.372057921598e+00 1.827998552316e+00 3.266556884714e-01 2.082360583635e-01 2.088987009941e+00 1.847861910289e-01 -1.263015266080e+00 6.790694668499e-01 -4.672150886500e-01 
0.000000000000e+00 1.735954469946e+00 -1.165023367477e+00 -1.246744443518e+00 -6.298225489084e-01 -1.984820180992e+00 2.975750060800e-01 6.339300596595e-01 -1.308518928772e-01 3.040301036095e-01 
0.000000000000e+00 0.000000000000e+00 -1.292937563924e+00 -1.126239225902e+00 1.190782911924e+00 -1.308772983895e+00 1.860151662666e-01 4.236733936881e-01 -1.019600826545e-01 1.943660914505e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.577711153032e+00 8.169358328160e-01 4.461531723828e-01 -4.365092541609e-02 -4.665979167188e-01 2.941231566184e-01 -1.034421113665e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -7.728975134989e-01 -1.601028244046e+00 -2.912685474827e-01 -2.434337858321e-01 6.736286084510e-01 2.624772904937e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -7.296773946362e-01 -7.965456279819e-03 9.710739102007e-01 -1.298967368574e-01 2.780242081241e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 7.945539612976e-01 -4.525143454606e-01 5.048901527575e-01 -1.211210193512e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 7.039911373514e-01 1.267535523498e-01 -3.714696735513e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -4.919586872214e-01 4.081509766399e-01 



Q:
-3.560272500571e-01 4.439873952785e-01 -6.935939248834e-01 6.597513287486e-02 3.701042887335e-01 1.873680253022e-01 -1.616846253861e-02 1.142209065421e-01 4.846147534278e-02 -5.435281546003e-02 
-9.344755733655e-01 -1.691554235406e-01 2.642533895704e-01 -2.513596481179e-02 -1.410065879813e-01 -7.138562494120e-02 6.160046789174e-03 -4.351719447171e-02 -1.846341016476e-02 2.070796067082e-02 
0.000000000000e+00 -8.799213803066e-01 -4.007708665994e-01 3.812160145536e-02 2.138528196492e-01 1.082645668876e-01 -9.342424307230e-03 6.599886483483e-02 2.800189963180e-02 -3.140602039975e-02 
0.000000000000e+00 0.000000000000e+00 -5.371036454452e-01 -1.260096502461e-01 -7.068831837949e-01 -3.578648243181e-01 3.088106413322e-02 -2.181569912327e-01 -9.255932185744e-02 1.038115266702e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 9.887789321494e-01 -1.266092216426e-01 -6.409685206678e-02 5.531080075230e-03 -3.907390568777e-02 -1.657821824708e-02 1.859359069582e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 5.307477730505e-01 -6.851618290904e-01 5.912435352117e-02 -4.176796180699e-01 -1.772124834679e-01 1.987557610042e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -5.886032010032e-01 -9.581355780502e-02 6.768677853804e-01 2.871804513252e-01 -3.220922591440e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -9.929517580142e-01 -9.993700299902e-02 -4.240112211755e-02 4.755572027992e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 5.375789043480e-01 -5.611563234389e-01 6.293746914713e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 7.464002047925e-01 6.654973585866e-01 



R:
2.512509079248e+00 -2.181265513645e+00 -1.316649918648e+00 -3.235549645996e-02 -2.553867638933e-01 -1.263236417243e+00 -1.428067524844e-01 8.551127106196e-01 -4.064323860885e-01 3.672920640296e-01 
0.000000000000e+00 -1.972851789714e+00 2.276016623827e-01 7.014634531795e-01 5.947854062317e-01 5.340587633903e-01 -3.303516655914e-01 6.131164883827e-02 -2.842350072136e-01 -1.020581006877e-01 
0.000000000000e+00 0.000000000000e+00 2.407240343439e+00 1.722528346094e+00 -4.505704077291e-01 3.392449531044e+00 -1.121444617851e-01 -1.448802456850e+00 7.311045593936e-01 -4.847285804893e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.595615664669e+00 6.397406649436e-01 3.502375215214e-01 -6.543701621428e-02 -3.985833699409e-01 2.393366716784e-01 -9.059576583919e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -1.456242593458e+00 -1.416208323337e+00 -2.740258546573e-01 2.820474174287e-01 3.146375562716e-02 2.179593898341e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.239676225669e+00 1.437893689789e-01 -1.965876544047e-01 -5.501588373900e-01 -1.563867947060e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -8.001939216933e-01 3.239240677887e-01 -4.348133701956e-01 1.296863513999e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.309558711582e+00 -4.522300337931e-01 -2.541297741346e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -6.591084569144e-01 4.900007103780e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 6.373330490059e-02 



RQ:
1.143817643298e+00 2.643043667321e+00 -1.774014655111e+00 -7.804541680122e-02 3.406398561353e-01 1.461454600932e+00 -9.542620239375e-01 4.390636920106e-01 7.812046500198e-01 -3.242676232229e-01 
1.843581807358e+00 1.334470111481e-01 -9.893074658739e-01 5.579861874654e-01 3.915081963850e-02 -2.951491456489e-01 1.302107099262e-02 -6.809912257186e-01 -1.407766316366e-01 4.534362093239e-03 
0.000000000000e+00 -2.118182245729e+00 -1.889928052623e+00 -5.708018640629e-01 1.154750215959e+00 -2.585301662617e+00 1.678124198417e+00 -1.154349560089e+00 -1.428583810585e+00 8.738827597003e-01 
0.000000000000e+00 0.000000000000e+00 -8.570109902230e-01 4.314991197035e-01 -1.023023164209e+00 -8.134730259318e-01 4.755641447902e-01 -3.951755882759e-01 -4.241791598500e-01 3.396131374910e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -1.439901996509e+00 -5.672756725063e-01 1.224964946486e+00 -3.455910828759e-01 4.516704416505e-01 3.294865537961e-01 -4.202787739855e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 6.579553960773e-01 -9.340137131103e-01 2.547201414468e-01 -6.965685047393e-01 2.194090527527e-02 -2.596005659042e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 4.709967037320e-01 -2.449715460025e-01 -8.077439833310e-01 9.726139591002e-02 8.578610393813e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -1.300328624888e+00 -3.739826989665e-01 8.562468804234e-03 -3.914678236392e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -3.543228021145e-01 7.355995090042e-01 -8.873200325455e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 4.757055182990e-02 4.241434606534e-02 



after QR method
3.389613438816e+00 8.353528415090e-01 -9.407588813616e-01 -8.836679698649e-02 2.662153718304e-01 9.208193563524e-01 -1.679190487850e+00 -7.649131336009e-02 9.684803888362e-01 -4.210340078049e-01 
0.000000000000e+00 -2.255459308097e+00 -2.369631451720e+00 4.483599022450e-02 -4.302583441345e-02 1.501664034048e+00 -1.100436653664e+00 1.606195241269e-01 5.797745141984e-01 6.122186271245e-02 
0.000000000000e+00 3.396555006850e-01 -2.418272556380e+00 6.381930767886e-01 2.168626103991e-02 1.687949829672e+00 -7.224251387618e-01 3.064680671409e-01 -1.977953231143e+00 1.049171012963e+00 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.590313467616e+00 1.546247056096e-02 -5.428692404289e-01 4.801586897193e-01 -7.278886615548e-03 8.015966164161e-02 -1.137955835345e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -1.756760412591e-06 -1.493147089725e+00 -7.096494288025e-02 8.624881081845e-02 -3.413451773294e-02 -1.213263562611e-01 -1.053724502475e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -9.816114823730e-01 -6.990660582700e-01 -2.535373674083e-01 5.841485452134e-01 -5.129627522854e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.691300230644e-02 -9.966172105716e-01 -1.135339714312e-01 -2.838529399430e-01 -4.005028591510e-02 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 9.432879572769e-01 1.855615509918e-01 -1.449241416203e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 6.418381898385e-01 -2.915442416256e-01 
0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 -1.444563958423e-02 5.666053960893e-02 




lambda[1] = (6.489488202111e-01 + i*0.000000000000e+00)
eigenvector = ( 1.084347985769e-01 7.134412595430e-02 3.825016669472e-01 -4.710034333103e-02 -7.178036005646e-01 1.815185466487e-01 -2.260059384135e-01 3.883814676961e-01 2.896964248456e-01 2.433276829523e-02 )

lambda[2] = (4.954990923633e-02 + i*0.000000000000e+00)
eigenvector = ( -2.137679779588e-01 -2.067736216989e-01 3.868289835104e-01 -3.111239463633e-02 -3.809389602373e-01 -1.251737268117e-01 6.447157358387e-01 -3.082012729665e-01 -2.959767270125e-01 4.372295101355e-02 )

lambda[3] = (9.432879572769e-01 + i*0.000000000000e+00)
eigenvector = ( 7.961973168490e-02 4.542056844048e-02 -1.827195427638e-02 -4.796091671390e-02 -3.495674270700e-01 2.072147711559e-01 -1.523120734300e-01 8.206337104041e-01 -3.554663294321e-01 2.886595340973e-02 )

lambda[4] = (-9.891143464723e-01 + i*1.084758631502e-01)

lambda[5] = (-9.891143464723e-01 + i*-1.084758631502e-01)

lambda[6] = (1.590313458807e+00 + i*0.000000000000e+00)
eigenvector = ( 6.237689761292e-02 -1.123122952786e-02 -2.528460320943e-01 -1.309875813614e-01 -3.819851386409e-01 8.155752888362e-01 -1.233767829110e-01 -6.772145198981e-02 2.719446111546e-01 1.002822249993e-01 )

lambda[7] = (-1.493147080915e+00 + i*0.000000000000e+00)
eigenvector = ( -5.613409816979e-01 7.781923574579e-01 1.436371665877e-02 -2.776019037479e-01 3.568072419003e-03 -2.548341655989e-03 -2.206089878200e-02 -1.175827116960e-02 -1.317349848144e-02 3.501595772874e-02 )

lambda[8] = (-2.336865932239e+00 + i*8.934379210213e-01)

lambda[9] = (-2.336865932239e+00 + i*-8.934379210213e-01)

lambda[10] = (3.389613438816e+00 + i*0.000000000000e+00)
eigenvector = ( -1.048719993204e-01 -2.176769763196e-01 -4.746940122415e-01 -2.593836246507e-01 -3.046652485206e-01 -2.594517466617e-01 8.686641827337e-02 4.052581266927e-01 5.096282896431e-01 2.395146921660e-01 )
```

## 5. 问题与分析
带双步位移的QR方法中，在复数的处理上遇到了问题。由于没有顾及到复数解，在初次运行时并没有得到正确的结果。后自行定义的复数的类型，解决了这个问题。